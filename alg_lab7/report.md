## 最佳调度问题的回溯算法

### 实验内容及目的

使用回溯算法解决最佳调度问题，需要给出具体的调度方案。由于搜索算法的时间是机器/任务规模的指数，因此需要探索更加有效的回溯算法，即更强的限界方法。

### 算法设计思路

回溯算法解决最佳调度问题的基本思路是，搜索的第t层表示第t个任务，t>=n时说明递归到底，可以更新最优解，否则依次尝试性地将这个任务分配给每个机器，若分配符合约束和限界，则进行递归搜索，否则进行回溯。

对于限界方法的实现，我实现了两个版本，第一个版本除去朴素的当前最短时间限界之外，只有简单的重复性剪枝，测试发现性能较差，因此这里只讨论第二种实现的具体方法。我的思路是修改每次任务分配的顺序，第一次先分配给当前负载最少的机器，下一轮分给次少的机器，以此类推。这里采用了贪心的算法思想，可以尽快地找到较好的解，然后就可以在搜索过程中通过较好解的限界来剪掉更多的低质量分支，算法效率得以大大提升。

### 代码解释

代码中采用了多个全局变量：
```C++
int min; // 当前最小时间
int n, k;  // n个任务，k个机器
std::vector<int> task_time;  // n个任务各自耗时
std::vector<std::vector<int>> best; // 当前最优解
std::vector<std::vector<int>> now; // 当前解
std::vector<int> machine_time; // 当前每台机器耗时
```

以及用于选择当前负载最少的机器的函数：
```C++
int SelectMachine(int used) {
    int min = 1000, i = -1;
    for(int m = 0; m < k; m++) {
        if(machine_time[m] > used && machine_time[m] < min) {
            min = machine_time[m];
            i = m;
        }
    }
    return i;
}
```

这个函数的功能是选择负载大于`used`且负载最小的机器。在调用时，`used`传递上一轮循环搜索过的机器的负载，这样每一轮搜索的机器负载逐渐增长。函数中使用严格小于而不用小于等于还有一个好处：负载相等的机器只选择一个进行试探性分配，达到了重复性剪枝的效果。

```C++
void BackTrack_o(int t, int now_time) {
    if (t >= n) {  // 到达叶节点，记录新的最优解
        min = now_time;
        best = now;
    } else {
        int i, used = -1;
        while(true) {
            i = SelectMachine(used);
            if(i == -1) return;
            now[i].push_back(t);
            machine_time[i] += task_time[t];       
            if (machine_time[i] < min) {   // 满足限界条件，试探性分配
                int new_time = std::max(now_time, machine_time[i]);
                BackTrack_o(t + 1, new_time);
                machine_time[i] -= task_time[t];
                now[i].pop_back();
                used = machine_time[i];
            }
            else {   // 回溯，还原机器状态
                machine_time[i] -= task_time[t];
                now[i].pop_back();
                return;
            }
        }
    }
}
```

这是算法的主体部分。函数包含了两个参数，`t`反应当前搜索的层数，`now_time`表示当前解耗时。首先判断是否进入到叶节点，如果是那么说明当前解已经是新的最优解，更新全局变量后返回。其余情况下，进入一个循环，表示当前层的不同选择试探。循环中先调用`SelectMachine`函数选出一个机器进行分配，修改全局变量`now`和`machine_time`。判断新的耗时是否小于当前解耗时，如果是说明试探是可行的，递归调用自身进入下一层，调用返回后修改`used`参数。不论是否可行，每轮循环末尾都要进行回溯，还原变量`now`和`machine_time`。另外，得益于每次是按照当前负载来挑选机器，因此只要出现了不可行的试探，那么后面的试探一定也不可行，就可以直接跳出返回，这样也进行了剪枝。

主函数中读取输入文件并将数据存放到全局变量中，调用算法并计时，算法执行完毕后打印算法耗时、任务调度方案以及每个机器的总负载。

### 测试结果

未开启编译优化，依次测试3个测例，结果如下（三个测例均有多个最优解，这里只展示一种分配方案）：
```
算法耗时: 0.144909 ms
机器0(total:112) 任务0 耗时47   任务3 耗时44    任务4 耗时21
机器1(total:111) 任务1 耗时20   任务6 耗时30    任务8 耗时28    任务9 耗时33
机器2(total:112) 任务2 耗时28   任务5 耗时45    任务7 耗时39

算法耗时: 17.0909 ms
机器0(total:182) 任务0 耗时98   任务3 耗时23    任务9 耗时61
机器1(total:182) 任务1 耗时84   任务6 耗时22    任务12 耗时76
机器2(total:179) 任务2 耗时50   任务11 耗时39   任务13 耗时53   任务14 耗时37
机器3(total:180) 任务4 耗时32   任务7 耗时76    任务8 耗时72
机器4(total:180) 任务5 耗时99   任务10 耗时81

算法耗时: 414.471 ms
机器0(total:125) 任务0 耗时39   任务11 耗时86
机器1(total:126) 任务1 耗时39   任务12 耗时34   任务13 耗时53
机器2(total:122) 任务2 耗时23   任务15 耗时99
机器3(total:120) 任务3 耗时45   任务8 耗时39    任务16 耗时36
机器4(total:120) 任务4 耗时100  任务10 耗时20
机器5(total:124) 任务5 耗时69   任务9 耗时55
机器6(total:125) 任务6 耗时21   任务14 耗时58   任务18 耗时46
机器7(total:126) 任务7 耗时81   任务17 耗时45
```

### 反思与收获

本次实验有一定难度，主要在于限界方法的设计。在基础的回溯算法上，可以根据问题特征针对性地设计限界方法，好的限界可以使得算法运行时间大大改善。我的实现方案还有很大的优化空间，有一些其他方向的限界思路可以实现，比如按照任务耗时进行排序、使用贪心法的解作为起始最优解等等。经过这次实验，我对回溯算法的实现以及优化都有了重要的实践经验。