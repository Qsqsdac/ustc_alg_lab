## 最长公共子序列

### 实验内容及目的

编程实现最长公共子序列（LCS）算法，并理解其核心思想。使用不同策略减少空间消耗。

### 算法设计思路

LCS问题是经典的动态规划问题，容易证明最优子结构性质、找到递归关系，采用动态规划方法能得到高效的算法。对于只用求出LCS长度、无需获得LCS的情况，在空间占用上，最基本的算法采用的是规模为m*n的二维表存储所有的子问题解，但是根据其计算顺序，及时丢弃使用完的子问题解，可以将空间优化为2\*min(m,n)乃至于min(m,n)。

### 代码解释

```C++
int LCS_1(string x, string y) {  // S = O(mn)
    int m = x.length();
    int n = y.length();
    char **b = new char*[m+1];  
    for(int i = 0; i <= m; ++i) {
        b[i] = new char[n+1];     // '\', '|', '-'
    }   
    int c[m+1][n+1];
    for(int i=0; i<=m; i++) 
        c[i][0] = 0;
    for(int j=0; j<=n; j++) 
        c[0][j] = 0;
    for(int i=1; i<=m; i++) {
        for(int j=1; j<=n; j++) {
            if(x[i-1] == y[j-1]) {
                c[i][j] = c[i-1][j-1] + 1;
                b[i][j] = '\\';
            } else if(c[i-1][j] >= c[i][j-1]) {
                c[i][j] = c[i-1][j];
                b[i][j] = '|';
            } else {
                c[i][j] = c[i][j-1];
                b[i][j] = '-';
            }
        }
    }
    if(c[m][n] > 0) {
        cout << "LCS: ";
        printLCS(b, x, m, n);
        cout << endl << "长度: ";
    }
    return c[m][n];
}
```

首先是基础算法，空间占用为O(mn)。这个函数承担了计算LCS长度和记录解路径的功能。采用两个二维数组c和b分别记录当前子问题公共子序列长度和递推方向。b使用二维指针的方式定义是为了切合语法，传递到打印函数中以打印LCS。在子问题的逐步求解过程中，首先将第0行和第0列初始化。接下来按照从上到下、从左到右的顺序计算。每一个子问题中，首先判断这一行、这一列的数列元素是否相等，若相等则由左上角元素取得当前解，否则比较上方元素和左侧元素的大小，选择较大者取得当前解。执行结束后，调用`printLCS`函数从b中得到LCS并打印。

```C++
void printLCS(char **b, string x, int i, int j) {
    if(i == 0 || j == 0) 
        return;
    if(b[i][j] == '\\') {
        printLCS(b, x, i-1, j-1);
        cout << x[i-1];
    } else if(b[i][j] == '|') {
        printLCS(b, x, i-1, j);
    } else {
        printLCS(b, x, i, j-1);
    }
}
```

打印函数通过递归地访问b来完成，根据当前b中元素指示的递推方向来决定下一次的访问位置，同时在递推方向为'\\'时会打印数列中对应位置的元素。递归的访问顺序与求解时相反，是从右下角向左上，因此需要在递归返回时执行打印语句。

接下来是对这一原始算法的空间优化。因为LCS的记录必须通过完整的规模为m*n的二维表来存储，所以本实验完成的两个优化函数只有求解LCS长度的功能。

```C++
int LCS_2(string x, string y) {  // S = O(2*min(m,n))  
    int m = x.length();
    int n = y.length();
    int c[2][n+1];  // 这里已经保证了m>=n
    for(int i=0; i<=n; i++) 
        c[0][i] = 0;
    for(int i=1; i<=m; i++) {
        for(int j=0; j<=n; j++) {
            if(j == 0) 
                c[i%2][j] = 0;
            else if(x[i-1] == y[j-1]) 
                c[i%2][j] = c[(i-1)%2][j-1] + 1;
            else if(c[(i-1)%2][j] >= c[i%2][j-1]) 
                c[i%2][j] = c[(i-1)%2][j];
            else 
                c[i%2][j] = c[i%2][j-1];
        }
    }
    return c[m%2][n];
}
```

这是空间占用为2\*min(m,n)的优化方案。具体思路是每次只保留当前正在计算的这一行和前一行。由于每个元素只取决于其左上角、左侧、上方的三个元素，所以在计算第i行时，仅保留第i-1行的解就足够了。实现起来比较简单，只需要在`LCS_1`函数的基础上，把每个使用到行索引的地方修改为行索引对2取余。求解过程中，交替更新两个数组的值，不需要对求解的具体逻辑做明显修改。

```C++
int LCS_3(string x, string y) {  // S = O(min(m,n))
    int m = x.length();
    int n = y.length();
    int c[n+1];
    int temp = 0;  // 当前正在计算的值的左上位置值
    for(int i=0; i<=n; i++) 
        c[i] = 0;
    for(int i=1; i<=m; i++) {
        for(int j=0; j<=n; j++) {
            if(j == 0) {
                c[j] = 0;
                temp = 0;
            }
            else if(x[i-1] == y[j-1]) {
                swap(c[j], temp);
                c[j]++;
            }
            else if(c[j] >= c[j-1]) 
                temp = c[j];
            else {
                temp = c[j];
                c[j] = c[j-1];
            }
        }
    }
    return c[n];
}
```

这是空间占用为min(m,n)的优化方案。`LCS_2`实质上只用到了行递推的局限性，`LCS_3`进一步用到列递推的局限性。在计算(i, j)位置的解时，c[1..j-1]表示的是[i, 1..j-1]位置的解，c[j..n]表示的是[i-1, j..n]位置的解，另外需要一个单位的临时变量temp记录[i-1, j-1]位置的解。当前解可能需要的，[i-1, j-1]的解从temp中访问到，[i-1, j]的解从c[j]中访问到，[i, j-1]的解从c[j-1]中访问到。当前位置的解计算出来后，置入c[j]处，在此之前将c[j]的原值置入temp中，用于右侧下一个位置的计算。计算顺序仍然是从上到下、从左到右，边界处需要一些特殊处理。

主函数从控制台读取两个字符串输入，然后调用`LCS_1`、`LCS_2`、`LCS_3`三个函数。`LCS_1`函数中调用打印函数打印出LCS。比较三个函数计算出的LCS长度，若相同则打印，否则说明算法有误，打印错误提示信息。


### 测试结果

展示一个简单的测例结果：

```
请输入字符串x: 10010101011011110100
请输入字符串y: 001010101010101011
LCS: 001010101101111
长度: 15
```

主函数中判断了三个函数计算出的长度是否相等，相等时只会打印一次长度，否则会打印错误信息。

### 反思与收获

本次实验的难点主要在于`LCS_3`函数中求解时不同情况的处理，这需要细致的分析。通过本次实验，我掌握了动态规划方法的基本算法，熟悉了刻画最优子结构特征、写出动态规划方程、以自底向上的方式计算出最优值的全流程。另外，对于空间占用的优化是此前未曾详细探讨的方向，本次实验也让我有了一些空间分析的经验。